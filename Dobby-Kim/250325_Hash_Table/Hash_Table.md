# Hash Table

## 해시 테이블이란?

해시 테이블(Hash Table)은 키(Key)와 값(Value)의 쌍으로 데이터를 저장하는 자료구조로, 평균적으로 매우 빠른 데이터 조회(검색), 삽입, 삭제 작업을 지원한다.

### 주요 키워드 정리
- **해시(Hash)**: 데이터를 특정 크기의 고정된 값으로 변환하는 과정
- **해시 함수(Hash Function)**: 입력 값을 해시값으로 변환하는 함수
- **버킷(Bucket)**: 해시 테이블 내의 데이터를 저장하는 공간
- **충돌(Collision)**: 서로 다른 두 데이터가 같은 해시 키(같은 해쉬 버킷)으에 저장되는 현상

## 해시 테이블의 작동 원리

해시 테이블의 핵심은 **해시 함수(Hash Function)** 이다. 이 해시 함수는 입력된 키를 해시 값으로 변환하고, 이 해시 값을 기준으로 데이터를 테이블 내의 특정 위치(버킷)에 저장하거나 검색한다.

### 해시 함수(Hash Function)란?
해시 함수는 주어진 입력 값을 일정한 크기의 고정된 숫자로 변환하는 역할을 수행한다. 이때, 해시 함수는 해시 테이블의 성능에 직접적인 영향을 미친다.

따라서, `좋은 해시 함수`라는 것이 존재하게 된다. 좋은 해시 함수는 키를 균등하게 분산시켜 해시 테이블의 성능을 최적화한다.

#### 좋은 해시 함수의 특징

- **빠른 계산 속도**
- **낮은 충돌 빈도**: 서로 다른 입력 값에 대해서 서로 다른 해시 값을 최대한 많이 생성
- **균등한 데이터 분산**: 데이터를 해시 테이블 전체에 골고루 분산


### 해시 함수의 예시

예를 들어, 흔히 숫자 데이터를 저장할 때 간단한 나머지 연산을 사용하는 해시 함수를 생각할 수 있다.

```
hash(key) = key % 테이블 크기
```

예시로, 키가 15이고 테이블 크기가 10일 때,

```
hash(15) = 15 % 10 = 5
```
이렇게 계산된 5번 인덱스에 데이터를 저장하거나 검색한다.

### 해시 함수 예시
개발을 하다보면 흔히 SHA-256, BASE-256과 같은 해싱 알고리즘을 들을 수 있는데, 여기서 말하는 해싱 알고리즘은 해시 함수의 예시가 될 수 있다.
>  **MD5, SHA-256**: 암호화 및 데이터 무결성 검증에 사용되는 고급 해시 함수들로 데이터의 해시 값을 일정하게 유지하며 보안성을 보장.


## 해시 테이블 작동 과정
1. 키 입력 받기.
2. 키를 해시 함수에 넣어 해시 값을 계산.
3. 계산된 해시 값에 해당하는 인덱스에 데이터를 저장하거나 가져옴.

그리고 이때, 해시 값에 해당하는 인덱스 데이터를 저장하거나 가져올 때 충돌(Collision)이 발생할 수 있다.

## 충돌(Collision)의 문제
해시 함수는 서로 다른 입력 키에 대해 같은 해시 값을 만들 수 있다. 예를 들어, 앞서 설명한 해시 함수 `hash(key) = key % 테이블 크기`에서 테이블의 크기가 10일 때, 5, 15, 25, 35... 와 같은 Key값들은 전부 Hash Key를 5로 가지는데, 이때 같은 키값이 여러 record 데이터들을 가르키고 있는 것을 충돌이라고 한다.
충돌은 해시 테이블의 성능을 떨어뜨릴 수 있다. 따라서 이를 해결하기 위한 방법이 중요하다!

### 충돌 해결 방법

충돌을 해결하는 대표적 방법은 다음 두 가지가 있다.

| 방법                      | 특징                                      |
| ----------------------- | --------------------------------------- |
| 체이닝(Chaining)           | 충돌이 발생한 위치에 연결 리스트나 트리를 사용하여 데이터를 추가 저장 |
| 개방 주소법(Open Addressing) | 충돌 시 테이블 내의 다른 빈 버킷을 찾아 데이터를 저장         |

## 해시 테이블의 장점과 단점

### 장점
- 평균적으로 O(1)의 빠른 검색, 삽입, 삭제 성능
- 사용이 쉽고 직관적인 데이터 접근 방식

### 단점
- 해시 함수가 좋지 않으면 성능이 급격히 떨어질 수 있음
- 메모리 사용량이 높을 수 있음
- 메모리 오버헤드가 존재
